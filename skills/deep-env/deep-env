#!/usr/bin/env bash
#
# deep-env - Secure environment variable manager using macOS Keychain
#
# Stores ALL credentials in a SINGLE keychain entry as JSON.
# This means only ONE keychain password prompt, ever.
#
# Usage:
#   deep-env store KEY VALUE    - Store a single credential
#   deep-env sync [project]     - Generate .env.local from Keychain
#   deep-env list               - List stored credentials (masked)
#   deep-env get KEY            - Get a single value (for scripting)
#   deep-env delete KEY         - Remove a credential
#   deep-env push               - Push to iCloud (encrypted)
#   deep-env pull               - Pull from iCloud (encrypted)

set -e

# Constants
KEYCHAIN_SERVICE="deep-env"
KEYCHAIN_ENTRY="deep-env-credentials"  # Single entry for ALL credentials
CONFIG_DIR="$HOME/.config/deep-env"
PROJECTS_CONF="$CONFIG_DIR/projects.conf"
PROJECT_KEYS_FILE="$CONFIG_DIR/project-keys.json"
CREDENTIALS_CACHE="$CONFIG_DIR/.credentials_cache"  # Temp cache for batch ops
ICLOUD_DIR="$HOME/Library/Mobile Documents/com~apple~CloudDocs"
ICLOUD_SYNC_DIR="$ICLOUD_DIR/.deep-env"
ENCRYPTED_FILE="$ICLOUD_SYNC_DIR/credentials.enc"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# ============================================================================
# Utility Functions
# ============================================================================

print_header() {
    echo -e "${BOLD}${BLUE}$1${NC}"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1" >&2
}

print_warning() {
    echo -e "${YELLOW}!${NC} $1"
}

print_info() {
    echo -e "${CYAN}→${NC} $1"
}

mask_value() {
    local value="$1"
    local len=${#value}
    if [ $len -le 8 ]; then
        echo "********"
    else
        echo "${value:0:4}...${value: -4}"
    fi
}

ensure_config_dir() {
    mkdir -p "$CONFIG_DIR"
}

# ============================================================================
# JSON Helper Functions (pure bash, no jq dependency)
# ============================================================================

# Escape a string for JSON
json_escape() {
    local str="$1"
    str="${str//\\/\\\\}"      # Backslash
    str="${str//\"/\\\"}"      # Double quote
    str="${str//$'\n'/\\n}"    # Newline
    str="${str//$'\r'/\\r}"    # Carriage return
    str="${str//$'\t'/\\t}"    # Tab
    echo "$str"
}

# Unescape a JSON string
json_unescape() {
    local str="$1"
    str="${str//\\n/$'\n'}"    # Newline
    str="${str//\\r/$'\r'}"    # Carriage return
    str="${str//\\t/$'\t'}"    # Tab
    str="${str//\\\"/\"}"      # Double quote
    str="${str//\\\\/\\}"      # Backslash (must be last)
    echo "$str"
}

# Get a value from JSON object (simple key-value parsing)
json_get() {
    local json="$1"
    local key="$2"
    # Extract value for key - handles escaped quotes in values
    local value
    value=$(echo "$json" | grep -o "\"$key\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" | head -1 | sed 's/.*:[[:space:]]*"\(.*\)"/\1/')
    if [ -n "$value" ]; then
        json_unescape "$value"
    fi
}

# Set a value in JSON object (returns new JSON)
json_set() {
    local json="$1"
    local key="$2"
    local value="$3"
    local escaped_value
    escaped_value=$(json_escape "$value")

    if [ -z "$json" ] || [ "$json" = "{}" ]; then
        echo "{\"$key\":\"$escaped_value\"}"
        return
    fi

    # Check if key exists
    if echo "$json" | grep -q "\"$key\"[[:space:]]*:"; then
        # Replace existing key
        echo "$json" | sed "s|\"$key\"[[:space:]]*:[[:space:]]*\"[^\"]*\"|\"$key\":\"$escaped_value\"|"
    else
        # Add new key (insert before closing brace)
        echo "$json" | sed "s|}$|,\"$key\":\"$escaped_value\"}|"
    fi
}

# Delete a key from JSON object
json_delete() {
    local json="$1"
    local key="$2"

    # Remove the key-value pair (handle both with and without trailing comma)
    echo "$json" | sed -E "s/,?\"$key\"[[:space:]]*:[[:space:]]*\"[^\"]*\",?//g" | sed 's/,}/}/g' | sed 's/{,/{/g'
}

# List all keys from JSON object
json_keys() {
    local json="$1"
    echo "$json" | grep -oE '"[^"]+":' | sed 's/"//g; s/://g' | sort -u
}

# ============================================================================
# Keychain Functions (Single Entry Storage)
# ============================================================================

# Read ALL credentials from keychain (single access)
keychain_read_all() {
    local json
    json=$(security find-generic-password -a "$KEYCHAIN_SERVICE" -s "$KEYCHAIN_ENTRY" -w 2>/dev/null) || echo "{}"
    echo "$json"
}

# Write ALL credentials to keychain (single access)
keychain_write_all() {
    local json="$1"
    local json_size=${#json}

    # Check if payload is too large
    if [ "$json_size" -gt 15000 ]; then
        print_error "Credential payload too large for keychain: $json_size bytes"
        print_info "macOS Keychain has a ~16KB limit per entry"
        print_info "Recommended: Split credentials using project-specific storage"
        return 1
    fi

    # Delete existing entry if present
    security delete-generic-password -a "$KEYCHAIN_SERVICE" -s "$KEYCHAIN_ENTRY" 2>/dev/null || true

    # Add new entry with the JSON blob - CAPTURE ERRORS
    local error_output
    if ! error_output=$(security add-generic-password \
        -a "$KEYCHAIN_SERVICE" \
        -s "$KEYCHAIN_ENTRY" \
        -w "$json" \
        -U 2>&1); then
        print_error "Failed to store credentials in keychain"
        print_error "Error: $error_output"
        return 1
    fi

    return 0
}

# Store a single credential (read-modify-write)
keychain_store() {
    local key="$1"
    local value="$2"

    # Read current state
    local json
    json=$(keychain_read_all)

    # Update
    json=$(json_set "$json" "$key" "$value")

    # Write back
    keychain_write_all "$json"
}

# Get a single credential
keychain_get() {
    local key="$1"
    local json
    json=$(keychain_read_all)
    json_get "$json" "$key"
}

# Delete a single credential
keychain_delete() {
    local key="$1"

    local json
    json=$(keychain_read_all)
    json=$(json_delete "$json" "$key")
    keychain_write_all "$json"
}

# List all credential keys
keychain_list() {
    local json
    json=$(keychain_read_all)
    json_keys "$json"
}

# Get all credentials as key=value pairs (for sync/push)
keychain_export_all() {
    local json
    json=$(keychain_read_all)

    local keys
    keys=$(json_keys "$json")

    while IFS= read -r key; do
        [ -z "$key" ] && continue
        local value
        value=$(json_get "$json" "$key")
        if [ -n "$value" ]; then
            echo "$key=$value"
        fi
    done <<< "$keys"
}

# ============================================================================
# Migration: Import old individual keychain entries
# ============================================================================

migrate_old_entries() {
    print_header "Migrating old keychain entries to new format"
    echo ""

    # List of known keys from the old format
    local keys_file="$CONFIG_DIR/keys.txt"
    local known_keys=(
        "ANTHROPIC_API_KEY"
        "OPENAI_API_KEY"
        "NEXT_PUBLIC_SUPABASE_URL"
        "NEXT_PUBLIC_SUPABASE_ANON_KEY"
        "SUPABASE_SERVICE_ROLE_KEY"
        "DATABASE_URL"
        "GMAIL_USER"
        "GMAIL_APP_PASSWORD"
        "API_SECRET_KEY"
        "STRIPE_SECRET_KEY"
    )

    # Add keys from tracking file
    if [ -f "$keys_file" ]; then
        while IFS= read -r key; do
            [[ -n "$key" ]] && known_keys+=("$key")
        done < "$keys_file"
    fi

    # Read current new-format JSON
    local json
    json=$(keychain_read_all)

    local migrated=0
    for key in "${known_keys[@]}"; do
        # Try to read from old individual entry
        local value
        value=$(security find-generic-password -a "$KEYCHAIN_SERVICE" -s "$key" -w 2>/dev/null) || continue

        if [ -n "$value" ]; then
            # Add to JSON
            json=$(json_set "$json" "$key" "$value")
            print_success "Migrated $key"
            ((migrated++))

            # Delete old individual entry
            security delete-generic-password -a "$KEYCHAIN_SERVICE" -s "$key" 2>/dev/null || true
        fi
    done

    if [ $migrated -gt 0 ]; then
        # Write the combined JSON
        keychain_write_all "$json"
        echo ""
        print_success "Migrated $migrated credentials to new single-entry format"
    else
        print_info "No old entries found to migrate"
    fi
}

# ============================================================================
# Project-Specific Key Management
# ============================================================================

get_key_project() {
    local key="$1"
    if [ -f "$PROJECT_KEYS_FILE" ]; then
        grep "\"$key\":" "$PROJECT_KEYS_FILE" 2>/dev/null | sed 's/.*: *"\([^"]*\)".*/\1/' | head -1
    fi
}

set_key_project() {
    local key="$1"
    local project="$2"
    ensure_config_dir

    if [ ! -f "$PROJECT_KEYS_FILE" ]; then
        echo "{}" > "$PROJECT_KEYS_FILE"
    fi

    local temp_file=$(mktemp)
    if [ -s "$PROJECT_KEYS_FILE" ] && [ "$(cat "$PROJECT_KEYS_FILE")" != "{}" ]; then
        grep -v "\"$key\":" "$PROJECT_KEYS_FILE" | grep -v "^{$" | grep -v "^}$" > "$temp_file" || true
        echo "{" > "$PROJECT_KEYS_FILE"
        if [ -s "$temp_file" ]; then
            cat "$temp_file" >> "$PROJECT_KEYS_FILE"
            echo "," >> "$PROJECT_KEYS_FILE"
        fi
        echo "  \"$key\": \"$project\"" >> "$PROJECT_KEYS_FILE"
        echo "}" >> "$PROJECT_KEYS_FILE"
    else
        echo "{" > "$PROJECT_KEYS_FILE"
        echo "  \"$key\": \"$project\"" >> "$PROJECT_KEYS_FILE"
        echo "}" >> "$PROJECT_KEYS_FILE"
    fi
    rm -f "$temp_file"
}

unset_key_project() {
    local key="$1"
    if [ -f "$PROJECT_KEYS_FILE" ]; then
        local temp_file=$(mktemp)
        grep -v "\"$key\":" "$PROJECT_KEYS_FILE" > "$temp_file" || true
        mv "$temp_file" "$PROJECT_KEYS_FILE"
    fi
}

get_project_display_name() {
    local project="$1"
    case "$project" in
        "$HOME/Deep-Personality"|"deep-personality"|"dp")
            echo "Deep-Personality"
            ;;
        *)
            basename "$project"
            ;;
    esac
}

normalize_project_name() {
    local project="$1"
    case "$project" in
        "dp"|"deep-personality"|"$HOME/Deep-Personality"|"Deep-Personality")
            echo "deep-personality"
            ;;
        *)
            echo "$project"
            ;;
    esac
}

get_project_keys() {
    local project_dir="$1"
    local env_example=""

    for template in ".env.example" ".env.template" ".env.sample" ".env.local.example"; do
        if [ -f "$project_dir/$template" ]; then
            env_example="$project_dir/$template"
            break
        fi
    done

    if [ -z "$env_example" ]; then
        return
    fi

    grep -E "^[A-Za-z_][A-Za-z0-9_]*=" "$env_example" 2>/dev/null | \
        sed 's/=.*//' | \
        sort -u
}

# ============================================================================
# Commands
# ============================================================================

cmd_store() {
    local project=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                project=$(normalize_project_name "$2")
                shift 2
                ;;
            --global|-g)
                project=""
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    if [ $# -eq 2 ]; then
        local key="$1"
        local value="$2"

        if keychain_store "$key" "$value"; then
            if [ -n "$project" ]; then
                set_key_project "$key" "$project"
                local display_name=$(get_project_display_name "$project")
                print_success "Stored ${BOLD}$key${NC} (project: $display_name)"
            else
                print_success "Stored ${BOLD}$key${NC} (global)"
            fi
        else
            print_error "Failed to store $key"
            exit 1
        fi
    else
        print_error "Usage: deep-env store [--project PROJECT] KEY VALUE"
        exit 1
    fi
}

cmd_sync() {
    local target_dir=""
    local env_filename=".env.local"

    if [ $# -eq 0 ]; then
        target_dir="$(pwd)"
    elif [ "$1" = "." ]; then
        target_dir="$(pwd)"
    elif [ "$1" = "deep-personality" ] || [ "$1" = "dp" ]; then
        target_dir="$HOME/Deep-Personality"
    elif [ -d "$1" ]; then
        target_dir="$1"
    elif [ -d "$HOME/$1" ]; then
        target_dir="$HOME/$1"
    else
        print_error "Directory not found: $1"
        exit 1
    fi

    if [ -n "$2" ]; then
        env_filename="$2"
    fi

    if [ ! -d "$target_dir" ]; then
        print_error "Directory not found: $target_dir"
        exit 1
    fi

    local env_file="$target_dir/$env_filename"
    local project_name=$(basename "$target_dir")

    print_header "Syncing to $env_file"
    echo ""

    # Read ALL credentials once (single keychain access!)
    local json
    json=$(keychain_read_all)

    local project_keys=$(get_project_keys "$target_dir")
    local all_keys=$(json_keys "$json")

    local temp_file=$(mktemp)

    cat > "$temp_file" << HEADER
# $project_name - Environment Variables
# Generated by deep-env from macOS Keychain
# DO NOT COMMIT THIS FILE

HEADER

    local synced=0
    local missing=()

    if [ -n "$project_keys" ]; then
        print_info "Using keys from .env.example"
        echo ""

        while IFS= read -r key; do
            [ -z "$key" ] && continue
            local value=$(json_get "$json" "$key")
            if [ -n "$value" ]; then
                echo "$key=$value" >> "$temp_file"
                print_success "$key"
                ((synced++))
            else
                missing+=("$key")
                print_warning "$key (not in Keychain)"
            fi
        done <<< "$project_keys"
    else
        print_info "No .env.example found - syncing all stored credentials"
        echo ""

        while IFS= read -r key; do
            [ -z "$key" ] && continue
            local value=$(json_get "$json" "$key")
            if [ -n "$value" ]; then
                echo "$key=$value" >> "$temp_file"
                print_success "$key"
                ((synced++))
            fi
        done <<< "$all_keys"
    fi

    mv "$temp_file" "$env_file"
    chmod 600 "$env_file"

    echo ""
    print_success "Synced $synced variables to $env_file"

    if [ ${#missing[@]} -gt 0 ]; then
        echo ""
        print_warning "Missing variables: ${missing[*]}"
        echo ""
        echo "Add missing credentials with:"
        for m in "${missing[@]}"; do
            echo "  deep-env store $m <value>"
        done
    fi
}

cmd_list() {
    print_header "Stored Credentials"
    echo ""

    # Read ALL credentials once (single keychain access!)
    local json
    json=$(keychain_read_all)

    local keys=$(json_keys "$json")

    if [ -z "$keys" ]; then
        print_info "No credentials stored yet"
        echo "Run ${BOLD}deep-env store KEY VALUE${NC} to add credentials"
        return
    fi

    local global_keys=""
    local dp_keys=""

    while IFS= read -r key; do
        if [ -n "$key" ]; then
            local value=$(json_get "$json" "$key")
            if [ -n "$value" ]; then
                local proj=$(get_key_project "$key")
                if [ -n "$proj" ]; then
                    case "$proj" in
                        "deep-personality"|"dp")
                            dp_keys="$dp_keys $key"
                            ;;
                        *)
                            global_keys="$global_keys $key"
                            ;;
                    esac
                else
                    global_keys="$global_keys $key"
                fi
            fi
        fi
    done <<< "$keys"

    if [ -n "$global_keys" ]; then
        echo -e "  ${BOLD}Global (all projects)${NC}"
        for key in $global_keys; do
            local value=$(json_get "$json" "$key")
            local masked=$(mask_value "$value")
            printf "    ${CYAN}%-33s${NC} %s\n" "$key" "$masked"
        done
        echo ""
    fi

    if [ -n "$dp_keys" ]; then
        echo -e "  ${BOLD}Deep-Personality${NC}"
        for key in $dp_keys; do
            local value=$(json_get "$json" "$key")
            local masked=$(mask_value "$value")
            printf "    ${CYAN}%-33s${NC} %s\n" "$key" "$masked"
        done
        echo ""
    fi
}

cmd_get() {
    local key="$1"

    if [ -z "$key" ]; then
        print_error "Usage: deep-env get KEY"
        exit 1
    fi

    local value=$(keychain_get "$key")

    if [ -n "$value" ]; then
        echo "$value"
    else
        print_error "Key not found: $key" >&2
        exit 1
    fi
}

cmd_delete() {
    local key="$1"

    if [ -z "$key" ]; then
        print_error "Usage: deep-env delete KEY"
        exit 1
    fi

    keychain_delete "$key"
    print_success "Deleted $key"
}

cmd_run() {
    if [ $# -eq 0 ]; then
        print_error "Usage: deep-env run <command>"
        exit 1
    fi

    # Read ALL credentials once (single keychain access!)
    local json
    json=$(keychain_read_all)

    local keys=$(json_keys "$json")

    while IFS= read -r key; do
        if [ -n "$key" ]; then
            local value=$(json_get "$json" "$key")
            if [ -n "$value" ]; then
                export "$key=$value"
            fi
        fi
    done <<< "$keys"

    exec "$@"
}

cmd_export() {
    # Read ALL credentials once (single keychain access!)
    local json
    json=$(keychain_read_all)

    local keys=$(json_keys "$json")

    while IFS= read -r key; do
        if [ -n "$key" ]; then
            local value=$(json_get "$json" "$key")
            if [ -n "$value" ]; then
                local escaped_value=$(printf '%s' "$value" | sed "s/'/'\\\\''/g")
                echo "export $key='$escaped_value'"
            fi
        fi
    done <<< "$keys"
}

cmd_import() {
    local env_file="${1:-.env.local}"

    if [ ! -f "$env_file" ]; then
        print_error "File not found: $env_file"
        exit 1
    fi

    print_header "Importing from $env_file"
    echo ""

    # Read current state once
    local json
    json=$(keychain_read_all)

    local count=0
    while IFS= read -r line || [ -n "$line" ]; do
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$line" ]] && continue

        if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"

            value="${value%\"}"
            value="${value#\"}"
            value="${value%\'}"
            value="${value#\'}"

            json=$(json_set "$json" "$key" "$value")
            print_success "Imported $key"
            ((count++))
        fi
    done < "$env_file"

    # Write all at once (single keychain access!)
    keychain_write_all "$json"

    echo ""
    print_success "Imported $count variables"
}

cmd_push() {
    print_header "Pushing credentials to iCloud"
    echo ""

    if [ ! -d "$ICLOUD_DIR" ]; then
        print_error "iCloud Drive not found at $ICLOUD_DIR"
        print_info "Make sure iCloud Drive is enabled in System Settings"
        exit 1
    fi

    mkdir -p "$ICLOUD_SYNC_DIR"

    # Read ALL credentials once (single keychain access!)
    local json
    json=$(keychain_read_all)

    local keys=$(json_keys "$json")
    local count=$(echo "$keys" | grep -c . || echo "0")

    if [ "$count" -eq 0 ]; then
        print_error "No credentials to push"
        exit 1
    fi

    # Build env file content
    local temp_file=$(mktemp)
    while IFS= read -r key; do
        [ -z "$key" ] && continue
        local value=$(json_get "$json" "$key")
        if [ -n "$value" ]; then
            echo "$key=$value" >> "$temp_file"
        fi
    done <<< "$keys"

    # Get or set password
    local password=""
    local password_file="$CONFIG_DIR/.master_pass"
    local stored_pass_file="$CONFIG_DIR/.sync_pass"

    if [ -n "$DEEP_ENV_PASSWORD" ]; then
        password="$DEEP_ENV_PASSWORD"
    elif [ -f "$stored_pass_file" ]; then
        password=$(cat "$stored_pass_file")
    elif [ -f "$password_file" ]; then
        echo -e "${CYAN}Enter your sync password:${NC}"
        read -s password
        echo ""
    else
        echo -e "${YELLOW}First time setup - create a sync password${NC}"
        echo "This password encrypts your credentials for iCloud sync."
        echo "You'll need this password on your other Macs."
        echo ""
        echo -e "${CYAN}Enter new sync password:${NC}"
        read -s password
        echo ""
        echo -e "${CYAN}Confirm password:${NC}"
        read -s password2
        echo ""

        if [ "$password" != "$password2" ]; then
            rm "$temp_file"
            print_error "Passwords don't match"
            exit 1
        fi

        echo -n "$password" | shasum -a 256 | cut -d' ' -f1 > "$password_file"
        chmod 600 "$password_file"

        echo ""
        read -p "Store password locally for auto-sync? (y/N): " -r store_pass
        if [[ $store_pass =~ ^[Yy]$ ]]; then
            echo -n "$password" > "$stored_pass_file"
            chmod 600 "$stored_pass_file"
            print_success "Password stored for auto-sync"
        fi
    fi

    if openssl enc -aes-256-cbc -salt -pbkdf2 -in "$temp_file" -out "$ENCRYPTED_FILE" -pass pass:"$password" 2>/dev/null; then
        rm "$temp_file"
        chmod 600 "$ENCRYPTED_FILE"
        print_success "Pushed $count credentials to iCloud"

        if [ -f "$PROJECT_KEYS_FILE" ]; then
            cp "$PROJECT_KEYS_FILE" "$ICLOUD_SYNC_DIR/"
            print_success "Synced project assignments to iCloud"
        fi

        echo ""
        print_info "Location: $ENCRYPTED_FILE"
        print_info "iCloud will sync this automatically to your other Macs"
    else
        rm "$temp_file"
        print_error "Encryption failed"
        exit 1
    fi
}

cmd_pull() {
    print_header "Pulling credentials from iCloud"
    echo ""

    if [ ! -f "$ENCRYPTED_FILE" ]; then
        print_error "No synced credentials found"
        print_info "Run 'deep-env push' on another Mac first"
        exit 1
    fi

    local password=""
    local stored_pass_file="$CONFIG_DIR/.sync_pass"

    if [ -n "$DEEP_ENV_PASSWORD" ]; then
        password="$DEEP_ENV_PASSWORD"
    elif [ -f "$stored_pass_file" ]; then
        password=$(cat "$stored_pass_file")
    else
        echo -e "${CYAN}Enter your sync password:${NC}"
        read -s password
        echo ""
    fi

    local temp_file=$(mktemp)

    if ! openssl enc -aes-256-cbc -d -salt -pbkdf2 -in "$ENCRYPTED_FILE" -out "$temp_file" -pass pass:"$password" 2>/dev/null; then
        rm "$temp_file" 2>/dev/null || true
        print_error "Decryption failed - wrong password?"
        exit 1
    fi

    # Read all into JSON, then write once (single keychain access!)
    local json="{}"
    local count=0

    while IFS= read -r line || [ -n "$line" ]; do
        [[ -z "$line" ]] && continue

        if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"

            json=$(json_set "$json" "$key" "$value")
            print_success "Pulled $key"
            ((count++))
        fi
    done < "$temp_file"

    rm "$temp_file"

    # Write all at once!
    if ! keychain_write_all "$json"; then
        print_error "Failed to store credentials in keychain"
        print_info "Your credentials are safe in iCloud at:"
        print_info "$icloud_file"
        print_info ""
        print_info "Manual recovery:"
        print_info "1. Check iCloud sync status in System Settings"
        print_info "2. Try again: deep-env pull"
        print_info "3. Contact support if issue persists"
        exit 1
    fi

    # Verify write succeeded
    local verify=$(keychain_read_all)
    if [ "$verify" = "{}" ] || [ -z "$verify" ]; then
        print_error "Keychain write verification failed"
        print_error "Credentials were not stored correctly"
        exit 1
    fi

    local password_file="$CONFIG_DIR/.master_pass"
    if [ ! -f "$password_file" ]; then
        echo -n "$password" | shasum -a 256 | cut -d' ' -f1 > "$password_file"
        chmod 600 "$password_file"
    fi

    local icloud_project_keys="$ICLOUD_SYNC_DIR/project-keys.json"
    if [ -f "$icloud_project_keys" ]; then
        cp "$icloud_project_keys" "$PROJECT_KEYS_FILE"
        print_success "Pulled project assignments from iCloud"
    fi

    # Count credentials from the stored JSON instead of relying on the counter
    local stored_count=$(echo "$verify" | grep -o '"[^"]*":' | wc -l | tr -d ' ')

    echo ""
    print_success "Pulled $stored_count credentials from iCloud"
    echo ""
    print_info "Run 'deep-env sync' to generate .env.local"
}

cmd_migrate() {
    migrate_old_entries
}

cmd_assign() {
    if [ $# -lt 1 ]; then
        print_error "Usage: deep-env assign KEY [--project PROJECT | --global]"
        exit 1
    fi

    local key="$1"
    shift

    local value=$(keychain_get "$key")
    if [ -z "$value" ]; then
        print_error "Key not found: $key"
        exit 1
    fi

    local project=""
    local make_global=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                project=$(normalize_project_name "$2")
                shift 2
                ;;
            --global|-g)
                make_global=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    if [ "$make_global" = true ]; then
        unset_key_project "$key"
        print_success "$key is now global (all projects)"
    elif [ -n "$project" ]; then
        set_key_project "$key" "$project"
        local display_name=$(get_project_display_name "$project")
        print_success "$key assigned to $display_name"
    else
        local current=$(get_key_project "$key")
        if [ -n "$current" ]; then
            local current_display=$(get_project_display_name "$current")
            print_info "Current: $current_display"
        else
            print_info "Current: global (all projects)"
        fi
        echo ""
        echo "Options:"
        echo "  1) deep-personality (Deep Personality)"
        echo "  2) global (all projects)"
        echo ""
        read -p "Choose (1-2): " choice
        case "$choice" in
            1)
                set_key_project "$key" "deep-personality"
                print_success "$key assigned to Deep-Personality"
                ;;
            2)
                unset_key_project "$key"
                print_success "$key is now global"
                ;;
            *)
                print_error "Invalid choice"
                exit 1
                ;;
        esac
    fi
}

cmd_doctor() {
    print_header "deep-env Diagnostics"

    # 1. Check if CLI is installed
    if [ -f "$HOME/.local/bin/deep-env" ]; then
        print_success "CLI installed: $HOME/.local/bin/deep-env"
    else
        print_error "CLI not found in $HOME/.local/bin/"
    fi

    # 2. Check iCloud sync
    local icloud_dir="$HOME/Library/Mobile Documents/com~apple~CloudDocs/.deep-env"
    if [ -d "$icloud_dir" ]; then
        print_success "iCloud directory exists"

        if [ -f "$icloud_dir/credentials.enc" ]; then
            local size=$(stat -f%z "$icloud_dir/credentials.enc" 2>/dev/null)
            print_info "credentials.enc size: $size bytes"
        else
            print_warning "No credentials.enc in iCloud"
        fi
    else
        print_error "iCloud .deep-env directory not found"
    fi

    # 3. Check keychain entry
    if security find-generic-password -s "$KEYCHAIN_ENTRY" -a "$KEYCHAIN_SERVICE" &>/dev/null; then
        local stored=$(keychain_read_all)
        local stored_size=${#stored}
        local key_count=$(echo "$stored" | grep -o '"[^"]*":' | wc -l | tr -d ' ')

        print_success "Keychain entry exists"
        print_info "Stored JSON size: $stored_size bytes"
        print_info "Credential count: $key_count"

        if [ "$stored_size" -gt 15000 ]; then
            print_warning "Keychain entry is large ($stored_size bytes)"
            print_warning "Consider splitting into project-specific credentials"
        fi
    else
        print_error "No keychain entry found"
    fi

    # 4. Check config directory
    if [ -d "$CONFIG_DIR" ]; then
        print_success "Config directory: $CONFIG_DIR"
        print_info "Files:"
        ls -lh "$CONFIG_DIR" 2>/dev/null | grep -v total || print_warning "No files in config directory"
    else
        print_warning "Config directory not found"
    fi

    # 5. Check sync password
    if [ -f "$MASTER_PASS_FILE" ]; then
        print_success "Sync password configured"
    else
        print_warning "No sync password found (will be prompted)"
    fi
}

cmd_help() {
    cat << 'EOF'
deep-env - Secure environment variable manager using macOS Keychain

Stores ALL credentials in a SINGLE keychain entry, so you only get
ONE password prompt no matter how many credentials you have.

USAGE:
    deep-env <command> [arguments]

COMMANDS:
    sync [dir]          Generate .env.local (default: current directory)
    store KEY VALUE     Store a credential in Keychain
    store -p PROJECT KEY VALUE   Store as project-specific
    list                List all stored credentials (grouped by project)
    assign KEY          Assign a key to a project (interactive)
    assign KEY -p dp    Assign to Deep Personality
    assign KEY -g       Make key global (all projects)
    get KEY             Get a single value (for scripting)
    delete KEY          Remove a credential from Keychain
    push                Encrypt & push to iCloud Drive
    pull                Pull & decrypt from iCloud Drive
    import [file]       Import from .env file into Keychain
    export              Output shell export statements
    run <command>       Run command with env vars injected
    migrate             Migrate old individual keychain entries to new format
    doctor              Run diagnostics on deep-env installation
    help                Show this help message

PROJECT SHORTCUTS:
    dp, deep-personality    ~/Deep-Personality

EXAMPLES:
    # Store credentials
    deep-env store ANTHROPIC_API_KEY sk-ant-xxx
    deep-env store -p dp ADMIN_EMAILS admin@example.com

    # Sync to project
    deep-env sync .
    deep-env sync dp

    # Cross-Mac sync
    deep-env push    # On main Mac
    deep-env pull    # On other Macs

    # Migrate from old format (run once)
    deep-env migrate

NOTES:
    - All credentials stored in ONE keychain entry = ONE password prompt
    - Run 'deep-env migrate' if you have old individual keychain entries

EOF
}

# ============================================================================
# Main
# ============================================================================

main() {
    ensure_config_dir

    local command="${1:-help}"
    shift || true

    case "$command" in
        store)
            cmd_store "$@"
            ;;
        sync)
            cmd_sync "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        assign)
            cmd_assign "$@"
            ;;
        get)
            cmd_get "$@"
            ;;
        delete|rm)
            cmd_delete "$@"
            ;;
        run)
            cmd_run "$@"
            ;;
        export)
            cmd_export "$@"
            ;;
        import)
            cmd_import "$@"
            ;;
        push)
            cmd_push "$@"
            ;;
        pull)
            cmd_pull "$@"
            ;;
        migrate)
            cmd_migrate "$@"
            ;;
        doctor)
            cmd_doctor "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            print_error "Unknown command: $command"
            echo "Run 'deep-env help' for usage"
            exit 1
            ;;
    esac
}

main "$@"
